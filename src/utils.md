# utils.py

# 代码说明

## 0.1 主要功能

该代码库主要功能是对预训练的语言模型进行微调，以适应特定的问答任务。代码实现了数据加载、模型加载、生成回答、评估回答质量以及通过DyPRAG技术注入适配器权重等功能。

## 0.1 架构说明

代码整体架构包括以下部分：

- `BaseDataset`类：提供数据预处理和评估指标计算的方法。
- 数据加载函数：负责从文件中读取和加载训练数据。
- 模型加载和配置函数：负责加载预训练模型及其配置。
- 生成函数：使用模型生成对给定问题的回答。
- 评估函数：评估生成的回答与真实答案的匹配度。
- 注入和移除适配器权重的函数：实现DyPRAG技术，动态调整模型参数。

## 0.1 关键组件

以下列出主要的类和函数：

### 0.1.1 类

- `BaseDataset`：包含数据预处理和评估方法。

### 0.1.2 函数

- `load_ragtruth`：加载真实答案数据。
- `load_data`：加载训练数据。
- `get_model_path`：获取模型路径。
- `get_attributes`：获取模型的属性。
- `get_model_class`：根据模型名称获取模型类。
- `get_model`：加载预训练模型。
- `model_generate`：使用模型生成回答。
- `read_complete`：从文件中读取数据。
- `evaluate`：评估生成的回答。
- `predict`：生成对问题的预测回答。
- `delta_inject`：向模型注入适配器权重。
- `delta_remove`：从模型中移除适配器权重。

这些组件共同构成了一个用于问答任务的语言模型训练和评估框架。

# 类分析

以下是代码中定义的类的详细分析：

BaseDataset

## 0.1 功能描述

`BaseDataset` 类主要用于处理和评估自然语言文本的答案。它包含方法来标准化答案，以及计算预测答案与真实答案之间的精确匹配度和F1分数。

## 0.1 参数说明

- `s`: 在 `normalize_answer` 方法中，这是一个需要标准化的字符串。
- `prediction`: 在 `exact_match_score` 和 `f1_score` 方法中，这是模型预测的答案。
- `ground_truth`: 在 `exact_match_score` 和 `f1_score` 方法中，这是真实答案，可以是字符串或字符串列表。
- `ground_truth_id`: 在 `exact_match_score` 和 `f1_score` 方法中，这是一个可选参数，用于提供与真实答案相关联的ID，用于获取所有别名。

## 0.1 返回值

- `normalize_answer`: 返回标准化后的字符串。
- `exact_match_score`: 返回一个包含正确匹配次数和错误匹配次数的字典。
- `f1_score`: 返回一个包含F1分数、精确度和召回率的字典。

## 0.1 实现逻辑

- `normalize_answer`: 该方法通过一系列函数来清理和标准化答案，包括移除冠词、固定空白字符、移除标点符号和转换为小写。
- `exact_match_score`: 该方法计算预测答案与真实答案之间的精确匹配度。如果提供了真实答案的ID，它还会获取所有别名进行比较。它使用标准化后的答案进行比较，并返回正确和错误匹配的次数。
- `f1_score`: 该方法计算预测答案与真实答案之间的F1分数，这是一个综合考虑精确度和召回率的度量。它同样处理别名，并且如果预测或真实答案是特殊的“yes”、“no”或“noanswer”，则会有特殊的处理逻辑。它使用分词后的答案计算公共token数量，然后基于这些数量计算F1分数、精确度和召回率。对于每个真实答案，它取最大的F1分数、精确度和召回率作为最终结果。

# 函数分析

以下是代码中定义的函数的详细分析：

load_ragtruth

以下是按照您提供的格式对该函数的分析：

## 0.1 功能描述

该函数的主要功能是从指定的JSONL文件中加载与给定任务类型（`data_type`）匹配的数据。

## 0.1 参数说明

- `data_name`: 字符串，用于确定要加载的数据集的名称，该参数用于构建数据文件路径。
- `data_type`: 字符串，用于过滤出与特定任务类型相匹配的数据。

## 0.1 返回值

- `data_list`: 列表，包含从JSONL文件中加载的与指定任务类型匹配的字典对象。

## 0.1 实现逻辑

1. 使用`os.path.join`构建数据文件的完整路径。
2. 初始化一个空列表`data_list`以存储匹配的数据。
3. 使用`with open`语句以只读模式打开数据文件，确保文件使用后能够正确关闭。
4. 遍历文件中的每一行，对每一行执行以下操作：
   - 使用`json.loads`将行内容从JSON格式字符串转换成Python的字典对象。
   - 检查字典对象的`'task_type'`键对应的值是否与`data_type`参数相等。
   - 如果匹配，将这个字典对象添加到`data_list`列表中。
5. 当所有行处理完毕后，关闭文件。
6. 函数返回填充了匹配数据的`data_list`列表。

注意：这个函数假设`ROOT_DIR`变量已经定义，并且`source_info.jsonl`文件位于正确的路径下。此外，函数没有对文件读取过程中可能发生的异常进行处理，如文件不存在或文件格式错误等。

load_data

## 0.1 功能描述

该函数的主要功能是从指定目录加载特定名称和类型的数据集，并根据模型名称和是否使用投影器（projector）来处理和返回数据。

## 0.1 参数说明

- `data_name`: 字符串，指定要加载的数据集的名称。
- `data_type`: 字符串或`None`，指定要加载的数据集的类型。如果为`None`，则加载所有类型的数据。
- `model_name`: 字符串，指定与数据集关联的模型名称，用于构建数据文件路径。
- `projector`: 布尔值，默认为`False`，指示是否使用投影器处理数据。
- `data_dir`: 字符串或`None`，指定数据集所在目录的路径。如果为`None`，则使用默认目录`DATA_ROOT_DIR`。

## 0.1 返回值

- 如果`data_type`为`'total'`，则返回一个列表，其中包含一个元组，元组的第一个元素是文件名`'total.json'`，第二个元素是一个列表，包含所有数据类型合并后的数据。
- 如果`data_type`为`None`，则返回一个列表，其中包含所有找到的数据文件的文件名和数据。
- 如果`data_type`指定了具体类型，则返回一个列表，其中包含与该类型匹配的文件名和数据。

## 0.1 实现逻辑

1. 如果`data_dir`参数为`None`，则使用默认目录`DATA_ROOT_DIR`。
2. 打印出正在加载的目录路径。
3. 构建数据的输入目录路径，并打印出正在从该目录加载数据的消息。
4. 获取输入目录下的所有文件。
5. 如果文件数量大于1：
   - 如果`data_type`为`'total'`，则加载所有文件，并将它们合并成一个总的数据列表`total_data`，然后返回。
   - 对于其他情况，加载每个文件（除了`'total.json'`），并将它们添加到`solve_dataset`列表中。
   - 如果`data_type`为`None`，直接返回`solve_dataset`。
   - 如果`data_type`指定了具体类型，则检查该类型是否存在，如果存在，则返回与该类型匹配的数据。
6. 如果文件数量为1或没有指定文件类型，则假设存在`'total.json'`文件，加载它并返回。
7. 如果指定了无效的`data_type`，则抛出一个`ValueError`异常。

get_model_path

下面是根据您提供的格式对 `get_model_path` 函数的分析：

## 0.1 功能描述

该函数根据提供的模型名称（`model_name`），返回对应的模型路径字符串。如果提供的模型名称与函数内预定义的模型名称匹配，它将返回一个特定的路径前缀加上匹配的模型名称；否则，它将直接返回原始的模型名称。

## 0.1 参数说明

- `model_name`: 一个字符串，表示要获取路径的模型名称。

## 0.1 返回值

- 返回一个字符串，表示与 `model_name` 参数对应的模型路径。如果 `model_name` 与预定义的模型名称匹配，则返回一个包含路径和模型名称的字符串；如果不匹配，则返回原始的 `model_name` 参数值。

## 0.1 实现逻辑

1. 初始化一个空字符串变量 `path`。
2. 使用 `if-elif-else` 语句块检查 `model_name` 的值。
3. 如果 `model_name` 等于预定义的模型名称之一（例如 `'llama3-8b-instruct'`），则将 `path` 变量与相应的模型路径前缀连接起来，然后返回。
4. 如果 `model_name` 与任何预定义的模型名称都不匹配，则直接返回 `model_name`。
5. 需要注意的是，尽管 `path` 被初始化为空字符串，但在所有返回语句中都被用来连接模型路径前缀，这可能是代码的意图，但实际效果上，由于 `path` 是空字符串，这并不会对返回的路径产生影响。

需要注意的是，该函数在实现上存在一个小问题：即使 `path` 变量被赋值为空字符串，它仍然被用于连接操作。由于字符串连接操作不会改变结果字符串（因为 `"" + "anything"` 仍然等于 `"anything"`），所以这个 `path` 变量实际上是无效的，可以完全省略。正确的实现可能不需要这个 `path` 变量。

get_attributes

下面是根据您提供的格式对该 `get_attributes` 函数的分析：

## 0.1 功能描述

获取一个由点分隔的属性列表，并递归地访问嵌套属性。该函数主要用于访问深层嵌套的对象属性，例如在神经网络模型中的层结构。

## 0.1 参数说明

- `x (nn.Module)`: 一个 `torch.nn.Module` 的实例或者其子类的实例，这是要访问属性的对象。
- `attributes (str)`: 一个字符串，表示要访问的属性路径，属性之间用点（`.`）分隔。

## 0.1 返回值

返回最后一个属性对应的值。如果路径有效，这将是与直接访问 `x` 对象的嵌套属性相同的对象。

## 0.1 实现逻辑

1. 使用 `split('.')` 方法将传入的 `attributes` 字符串按点分隔成属性列表。
2. 循环遍历这个属性列表。
3. 在每次迭代中，使用 `getattr` 函数从当前对象 `x` 中获取对应的属性值，并将 `x` 更新为这个新值。
4. 当遍历完所有属性后，返回最终的属性值。

注意：如果属性路径中任何一个属性不存在，`getattr` 将抛出一个 `AttributeError`。因此，调用者需要确保路径是有效的，或者准备好处理这种异常。

get_model_class

## 0.1 功能描述

该函数`get_model_class`的主要功能是根据提供的模型名称`model_name`，返回相应的修改后的模型类。

## 0.1 参数说明

- `model_name (str)`: 用于指定要获取的模型类名称。该参数应为字符串类型，并且预期包含模型类的前缀。

## 0.1 返回值

- 返回类型：模型类（例如`LlamaForCausalLM`或`Qwen2ForCausalLM`）
- 返回值含义：函数将返回与`model_name`参数匹配的模型类。如果没有找到匹配的模型类，将抛出一个`ValueError`异常。

## 0.1 实现逻辑

1. 定义一个名为`model_classes`的字典，其中包含模型名称前缀与对应的模型类之间的映射关系。
2. 遍历`model_classes`字典中的每个键值对（`prefix, model_class`）。
3. 检查模型名称的前缀是否存在于提供的`model_name`字符串中，忽略大小写（通过`.lower()`方法）。
4. 如果找到匹配的前缀，则返回对应的模型类。
5. 如果遍历结束后没有找到匹配的模型类，抛出一个`ValueError`异常，并显示一条错误消息，提示提供的模型名称无效。

get_model

## 0.1 功能描述

该函数的主要功能是根据提供的模型名称生成一个预训练的模型实例、对应的分词器（tokenizer）以及生成配置。这个函数通常用于加载特定的预训练模型，以便进行文本生成或处理其他与自然语言相关的任务。

## 0.1 参数说明

- `model_name`: 一个字符串，用于指定要加载的预训练模型的名称。
- `max_new_tokens`: 一个整数，默认值为20，用于设置生成的文本中最大新令牌的数量。这个参数通常用于控制生成文本的长度。

## 0.1 返回值

- 一个包含三个元素的元组 `(model, tokenizer, generation_config)`：
  - `model`: 一个预训练的模型实例，由 `model_class.from_pretrained()` 方法创建。
  - `tokenizer`: 与模型对应的分词器，用于将文本转换为模型可以理解的令牌。
  - `generation_config`: 一个字典，包含用于文本生成的配置参数，如 `num_beams`（束数），`do_sample`（是否进行采样生成），`max_new_tokens`（最大新令牌数）等。

## 0.1 实现逻辑

1. 通过调用 `get_model_path(model_name)` 函数获取指定模型的路径。
2. 通过调用 `get_model_class(model_name)` 函数获取指定模型的类。
3. 使用 `model_class.from_pretrained()` 方法从指定路径加载预训练的模型，并设置相关参数，如数据类型（`torch_dtype`），低CPU内存使用（`low_cpu_mem_usage`），设备映射（`device_map`）和信任远程代码（`trust_remote_code`）。
4. 使用 `AutoTokenizer.from_pretrained()` 方法加载与模型对应的分词器，并设置信任远程代码。
5. 创建一个字典 `generation_config`，其中包含生成文本时需要的配置参数，如束数（`num_beams`），是否采样（`do_sample`），最大新令牌数（`max_new_tokens`）等，并确保设置了正确的pad令牌ID。
6. 返回包含模型、分词器和生成配置的元组。

model_generate

以下是根据您提供的格式对该函数的分析：

## 0.1 功能描述

该函数`model_generate`的主要功能是使用指定的模型和分词器生成文本，基于用户的输入提示。它适用于聊天机器人或文本生成任务，其中模型基于用户的初始提示生成响应。

## 0.1 参数说明

- `prompt`: 用户提供的文本提示，作为生成过程的开端。
- `model`: 使用的模型实例，用于生成文本。
- `tokenizer`: 与模型对应的分词器实例，用于处理输入和输出文本。
- `generation_config`: 生成配置，包含模型生成文本时需要的额外参数。

## 0.1 返回值

函数返回一个字符串`text`，它是模型根据用户提示生成的文本。

## 0.1 实现逻辑

1. 函数首先将用户提示包装到一个字典列表中，该列表表示聊天消息格式。
2. 使用`tokenizer.apply_chat_template`方法处理这些消息，并获取对应的`input_ids`。如果`add_generation_prompt`为`True`，则会添加额外的生成提示。
3. 计算输入ID序列的长度。
4. 将输入ID转换为张量，并将其unsqueeze以适配模型的输入格式，然后将其发送到模型的设备上。
5. 调用`model.generate`方法生成文本。这里，`attention_mask`被设置为全部为1的张量，以指示模型关注所有输入序列的位置。
6. 生成配置通过`**generation_config`传递给`model.generate`，这些配置可能包括生成步数、温度等。
7. 从生成结果中提取序列，并跳过输入序列的长度，以获得新生成的文本的ID。
8. 使用`tokenizer.decode`方法将输出ID转换为文本，并跳过特殊标记，如`[CLS]`或`[SEP]`。
9. 返回生成的文本。

read_complete

以下是对提供的 `read_complete` 函数的分析：

## 0.1 功能描述

该函数的主要功能是读取指定文件路径（`filepath`）的JSON文件，并将其内容解析为Python数据结构（通常是字典或列表）。如果文件读取成功，它还将返回文件内容的长度。

## 0.1 参数说明

- `filepath`: 字符串类型，表示要读取的文件的路径。

## 0.1 返回值

- 返回一个包含两个元素的元组：
  - 第一个元素是解析后的JSON数据，如果读取失败，则是一个空列表 `[]`。
  - 第二个元素是JSON数据的长度，如果读取失败，则为 `0`。

## 0.1 实现逻辑

1. 使用 `try` 块来捕获可能出现的异常，确保函数在遇到错误时不会崩溃。
2. 使用 `with open(filepath, 'r') as fin:` 语句打开指定的文件。这里的 `'r'` 模式表示以只读方式打开文件。
3. 利用 `json.load(fin)` 方法将文件中的JSON内容读取并解析为Python数据结构。
4. 将解析后的数据和其长度封装在一个元组中，并通过 `return` 语句返回。
5. 如果在文件读取或解析过程中遇到任何异常（例如文件不存在、文件不是有效的JSON格式等），`except` 块会被执行，并返回一个包含空列表和 `0` 的元组，表示读取失败。

需要注意的是，该函数没有明确指出它处理的是JSON文件，但是通过使用 `json.load` 可以推断出来。此外，该函数在捕获异常时没有打印错误信息或抛出特定的异常，这可能会导致调试困难。通常，更好的做法是捕获特定的异常，例如 `FileNotFoundError` 或 `json.JSONDecodeError`，以便可以更准确地处理不同类型的错误。

evaluate

## 0.1 功能描述

该函数`evaluate`的主要功能是评估一个预测值（pred）与真实值（ground_truth）之间的准确性和相似性。它通过计算精确匹配得分（exact match score, EM）和F1分数（包括精确度precision和召回率recall）来评估。

## 0.1 参数说明

- `pred`: 预测值，即模型生成的结果。
- `ground_truth`: 真实值，即实际的答案或目标输出。
- `with_cot`: 布尔型参数，指示是否包含cot（可能是context of the task）的特定处理。

## 0.1 返回值

函数返回一个包含以下键的字典：

- `eval_predict`: 处理后的预测值。
- `em`: 精确匹配得分的字符串表示，指示预测是否完全匹配真实值。
- `f1`: F1分数的字符串表示，衡量预测的精确性和召回率的调和平均。
- `prec`: 精确度的字符串表示，即正确预测的样本占预测为正样本的样本的比例。
- `recall`: 召回率的字符串表示，即正确预测的样本占实际为正样本的样本的比例。

## 0.1 实现逻辑

1. 如果`with_cot`参数为`False`，则移除预测值中的空白字符，并检查预测值中是否包含指定的停止字符（如句号、换行符、逗号等）。如果找到停止字符，则截断预测值到停止字符之前的位置。
2. 如果`with_cot`参数为`True`，则检查预测值中是否包含“the answer is”字样。如果存在，则从该字样之后开始截取预测值。
3. 对于两种情况，都会移除预测值前后的空白字符，并查找停止字符，如果找到则截断预测值。
4. 使用`BaseDataset.exact_match_score`方法计算精确匹配得分（EM）。
5. 使用`BaseDataset.f1_score`方法计算F1分数、精确度和召回率。
6. 将所有计算结果转换为字符串格式，并返回包含这些结果的字典。

predict

以下是对给定函数的分析：

## 0.1 功能描述

该函数`predict`的主要功能是使用预训练的模型和分词器来生成对给定问题的回答。它处理输入问题，可能还包括一些段落（如果提供），然后通过模型生成输出文本。

## 0.1 参数说明

- `model`: 预训练的模型，用于生成回答。
- `tokenizer`: 用于处理文本输入和输出的分词器。
- `generation_config`: 包含生成设置（如最大长度、温度等）的配置对象。
- `question`: 需要回答的问题文本。
- `with_cot`: 布尔值，指示是否需要上下文中的连贯性（可能是链式思维或者其他上下文信息）。
- `passages`: 可选参数，包含与问题相关的段落或上下文信息。

## 0.1 返回值

- `text`: 生成的回答文本，经过解码，不包含特殊的标记。

## 0.1 实现逻辑

1. 将模型设置为评估模式（`model.eval()`），确保不进行梯度计算。
2. 使用`get_prompt`函数获取输入的提示，该函数可能根据问题、段落和是否需要上下文连贯性构建输入序列。
3. 获取输入序列的长度，并将输入序列转换为一个PyTorch张量，增加一个批次维度，并移动到模型的设备上。
4. 使用`torch.no_grad()`上下文管理器确保不计算梯度，调用模型的`generate`方法，生成输出序列。这需要输入序列、注意力掩码（全1）和生成配置。
5. 从输出序列中提取有效的回答部分（去掉输入部分），并使用分词器解码输出张量，得到文本形式的回答。
6. 返回生成的文本回答。

delta_inject

## 0.1 功能描述

该函数的主要功能是向模型的层中注入一组差分权重（delta weights），这些权重通常用于微调模型的特定部分，例如LoRa（Low-Rank Adaptation）适配器。

## 0.1 参数说明

- `model`: 要注入差分权重的模型对象。
- `adapter_weights`: 一个包含差分权重的字典，键是权重在模型中的路径，值是对应的权重张量。

## 0.1 返回值

该函数不直接返回任何值，而是通过`setattr`修改了模型中相应模块的属性，添加了一个名为`delta`的新属性。

## 0.1 实现逻辑

1. 从`adapter_weights`的键中提取模块名称，通过移除每个键中最后两个点（`.`）分隔的部分来实现，这些通常是特定权重的后缀。
2. 遍历这些模块名称，使用一个未在代码段中定义的`get_attributes`函数来获取模型中对应的模块。
3. 对于每个模块，从`adapter_weights`中提取对应的`lora_A`和`lora_B`权重。
4. 计算差分权重`delta`，通过矩阵乘法`lora_B @ lora_A`来实现。
5. 将计算出的差分权重转换为`torch.float32`类型，并设置到模块的`delta`属性中。

注意：该分析基于提供的代码段，假设`get_attributes`函数能够正确地根据模块名称从模型中检索模块。此外，代码中没有处理可能出现的任何异常或错误，例如权重键不存在或权重形状不匹配等问题。

delta_remove

以下是对提供的 `delta_remove` 函数的分析：

## 0.1 功能描述

该函数的主要功能是从模型的层中移除所谓的“delta”权重。

## 0.1 参数说明

- `model`: 要从中移除delta权重的模型对象。
- `adapter_weights`: 一个包含delta权重的字典，其键是用于访问模型中相应层权重的路径。

## 0.1 返回值

该函数不返回任何值，它通过修改传入的`model`对象直接进行操作。

## 0.1 实现逻辑

1. 遍历`adapter_weights`字典中的所有键，提取模块名称（通过将键中的层名称和属性名称分离，并使用`.`进行连接）。
2. 将这些模块名称放入一个集合中，以消除重复项。
3. 对于集合中的每个模块名称，使用一个未在代码段中定义的`get_attributes`函数获取模型中的相应模块。
4. 使用`delattr`函数从这些模块中删除名为`delta`的属性，这实际上是从模型中移除了对应的delta权重。

注意：`get_attributes`函数没有在提供的代码段中定义，因此我假设它是一个能够根据提供的模块名称从模型中获取相应模块的辅助函数。此外，这段代码假设所有的模块都包含一个名为`delta`的属性，该属性包含了需要被移除的权重。

get_attributes

以下是对给定函数 `get_attributes` 的分析：

## 0.1 功能描述

该函数的主要功能是获取嵌套的模块属性。它接受一个 PyTorch `nn.Module` 实例和一个字符串 `attributes`，该字符串包含以点分隔的属性路径。函数将沿着这个路径递归地获取每个属性，最终返回最深层的属性值。

## 0.1 参数说明

- `x (nn.Module)`: 一个 PyTorch 的模块实例，通常是一个神经网络组件。
- `attributes (str)`: 一个字符串，其中包含需要访问的属性的路径，属性之间使用点号（`.`）分隔。

## 0.1 返回值

返回沿着属性路径最深层的属性值。如果路径有效，这个值通常是一个模块或模块的某个组件。

## 0.1 实现逻辑

1. 函数通过 `split('.')` 方法将字符串 `attributes` 分割成属性列表。
2. 它使用一个循环遍历这个属性列表。
3. 在每次迭代中，它使用 `getattr` 函数来获取当前 `x` 对象的下一个属性，并将结果赋值给 `x`。
4. 当循环结束时，`x` 将包含沿着属性路径最深层的属性值。
5. 函数返回最终的 `x` 值，即用户请求的属性。

这种实现方式允许用户通过提供一个简单的字符串路径，就可以访问嵌套的模块属性，而不需要手动逐级访问每个属性。这在处理复杂的模块结构时非常有用。
