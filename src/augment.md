augment.py

# 1. 代码说明

该代码是一个数据增强脚本的示例，它使用了不同的预训练语言模型来重写文本段落并生成问题-答案对。它主要用于问答（QA）数据集，支持多种数据集格式。

## 1.1. 主要功能

- 加载不同格式的问答数据集。
- 使用语言模型对文本段落进行重写。
- 生成基于给定段落的问题和答案。
- 将增强后的数据保存到文件。

## 1.2. 架构说明

代码的结构如下：

- 导入必要的库和模块。
- 定义多个加载不同数据集的函数。
- 定义重写段落的函数。
- 定义生成问题和答案的函数。
- 定义主函数，它组织上述功能，处理数据集，并保存结果。

## 1.3. 关键组件

- **数据加载函数**：
  - `load_popqa(data_path)`
  - `load_complexwebquestions(data_path)`
  - `load_ragtruth(data_path)`
  - `load_2wikimultihopqa(data_path)`
  - `load_hotpotqa(data_path)`
  - `load_iirc(data_path)`
  - `load_strategyqa(data_path)`
  - `load_default_format_data(data_path)`
- **重写函数**：

  - `get_rewrite(passage, model_name, model=None, tokenizer=None, generation_config=None)`

- **问题和答案生成函数**：

  - `get_qa(passage, model_name, model=None, tokenizer=None, generation_config=None)`

- **主函数**：

  - `main(args)`: 这是脚本的入口点，它处理命令行参数，加载模型和数据处理，最后保存结果。

- **辅助函数**：

  - `fix_json(output)`: 修正 JSON 输出格式。
  - `fix_qa(qa)`: 校验生成的问题-答案对格式。

- **命令行参数解析**：
  - 使用 `argparse` 库定义和解析命令行参数。

代码还包括了错误处理、重试逻辑和进度条显示，以提高用户体验。此外，它还支持通过命令行参数指定不同的模型和数据集，以及控制生成数据的样本数量和保存位置。

# 2. 函数分析

以下是代码中定义的函数的详细分析：

load_popqa

以下是对提供的 `load_popqa` 函数的分析：

## 2.1. 功能描述

该函数的主要功能是加载一个名为 `popQA.tsv` 的数据文件，该文件位于指定路径下。它读取文件内容，处理每行数据，并将其转换为一个包含问题和答案列表的字典列表，最后返回包含所有数据的字典。

## 2.2. 参数说明

- `data_path` (str): 一个字符串，表示包含 `popQA.tsv` 文件的目录路径。

## 2.3. 返回值

- `dict`: 一个字典，包含以下键值对：
  - `'total'`: 一个列表，其中包含字典，每个字典包含以下键值对：
    - `'test_id'`: 一个整数，表示数据行的索引。
    - `'question'`: 一个字符串，表示对应的问题。
    - `'answer'`: 一个列表，包含一个对象和其别名，这些是从原始数据集中提取的。

## 2.4. 实现逻辑

1. 将 `data_path` 与 `'popQA.tsv'` 拼接，形成完整的数据文件路径。
2. 使用 `pd.read_csv(data_path, sep='\t')` 读取该数据文件，其中 `sep='\t'` 表示数据文件使用制表符 (`\t`) 作为分隔符。
3. 初始化一个空列表 `new_dataset`，用于存储处理后的数据。
4. 遍历 `dataset` 的每个元素（即每行数据），通过索引获取对应的数据行。
5. 提取问题 (`'question'`) 和答案 (`'obj'` 和 `'o_aliases'`)。其中 `'o_aliases'` 是一个字符串，表示对象别名，使用 `eval()` 函数将其从字符串转换为列表。
6. 创建一个新的字典 `val`，包含 `'test_id'`，`'question'`，和 `'answer'`（包含 `'obj'` 和 `'o_aliases'` 转换后的列表）。
7. 将 `val` 添加到 `new_dataset` 列表中。
8. 返回一个包含 `new_dataset` 的字典，以 `'total'` 作为键。

注意：使用 `eval()` 函数来解析字符串可能存在安全风险，因为 `eval()` 可以执行任意 Python 代码。如果 `o_aliases` 字段是从不可信的来源获取的，这可能导致安全漏洞。在生产环境中，应该使用更安全的方法来解析字符串。

load_complexwebquestions

下面是根据您提供的格式对该函数的分析：

## 2.5. 功能描述

该函数`load_complexwebquestions`的主要功能是加载并处理一个 JSON 格式的数据文件，该文件包含了一系列复杂的网页问题及其答案。它会读取文件中的数据，构建一个新的数据结构，并返回这个结构。

## 2.6. 参数说明

- `data_path`: 字符串，表示数据文件所在的目录路径。该路径将用于定位并读取名为`ComplexWebQuestions_dev.json`的 JSON 数据文件。

## 2.7. 返回值

- 返回一个字典`ret`，包含以下内容：
  - `'total'`: 键对应一个列表`new_dataset`，其中包含了从原始数据中处理后的每个问题及其答案的字典。

每个问题字典包含以下键：

- `'test_id'`: 问题的唯一标识符，由其在原始数据集中的枚举索引确定。
- `'question'`: 问题的字符串描述。
- `'answer'`: 一个列表，包含该问题的所有答案以及答案的别名（去除重复项）。

## 2.8. 实现逻辑

1. 将`data_path`与文件名`ComplexWebQuestions_dev.json`拼接，形成完整的数据文件路径。
2. 使用`with open`语句以只读模式打开文件，确保文件在使用后正确关闭。
3. 使用`json.load`将文件中的 JSON 数据解析为 Python 的字典列表`dataset`。
4. 遍历`dataset`中的每个元素，为其创建一个新的字典`val`，包含以下步骤：
   - 获取问题字符串`question`。
   - 初始化答案列表`answer`。
   - 遍历当前问题的所有答案，将答案本身和别名添加到`answer`列表中。
   - 将`answer`列表转换为集合以去除重复项，然后再次转换为列表。
   - 构建新的字典`val`，包含`'test_id'`, `'question'`, 和处理后的`'answer'`。
   - 将`val`添加到新的数据集列表`new_dataset`中。
5. 创建最终的返回字典`ret`，其中包含键`'total'`对应于处理后的数据集列表`new_dataset`。
6. 返回`ret`字典，包含所有处理后的数据。

load_ragtruth

以下是对给定函数 `load_ragtruth` 的分析：

## 2.9. 功能描述

该函数的主要功能是从指定路径加载包含 QA 任务类型的源信息，解析 JSONL 格式的文件，并将解析后的数据转换成一个新的数据格式，最终返回包含所有转换后数据的一个字典。

## 2.10. 参数说明

- `data_path`: 一个字符串，表示包含 `source_info.jsonl` 文件的目录路径。

## 2.11. 返回值

返回一个字典 `ret`，其中包含一个键 `'total'`，其对应的值是一个列表 `new_dataset`。这个列表包含从原始数据中提取并转换格式后的所有 QA 任务数据。

## 2.12. 实现逻辑

1. 根据传入的 `data_path`，构建 `source_info.jsonl` 文件的完整路径，并将其存储在 `source_info_path` 变量中。
2. 初始化一个空列表 `data_list`，用于存储从文件中解析出的数据。
3. 使用 `with` 语句打开 `source_info.jsonl` 文件，逐行读取并解析 JSON 数据。
4. 检查每行数据中的 `'task_type'` 字段是否为 `'QA'`，如果是，将该行数据添加到 `data_list` 列表中。
5. 初始化一个空列表 `new_dataset`，用于存储转换格式后的数据。
6. 遍历 `data_list` 列表，对于每个数据项，提取 `'source_info'` 字段中的 `'question'` 和 `'passages'`。
7. 解析 `'passages'` 字段，提取前三个段落，并将它们添加到 `passages_list` 列表中。
8. 创建一个新的字典 `val`，包含 `'test_id'`、`'question'` 和 `'passages'`，并将其添加到 `new_dataset` 列表中。
9. 创建最终返回的字典 `ret`，将 `new_dataset` 作为 `'total'` 键的值。
10. 返回 `ret` 字典。

注意：这个函数假设每个数据项的 `'passages'` 字段包含至少三个以 `'passage'` 开头的段落，并且这些段落是用 `'passage'` 分隔的。如果数据格式不符合这个假设，函数可能会失败或产生不正确的结果。此外，该函数没有进行错误处理，例如检查文件是否存在或处理 JSON 解析错误。

load_2wikimultihopqa

## 2.13. 功能描述

该函数的主要功能是从指定路径加载 2wikimultihopqa 数据集，该数据集可能是一个用于多跳问答的 JSON 格式数据集。函数读取数据集中的问题和答案，以及与之相关的上下文信息，并将数据转换成一个新的格式，便于后续处理。

## 2.14. 参数说明

- `data_path`: 字符串，指定包含数据集文件的目录路径。

## 2.15. 返回值

返回一个字典，包含以下内容：

- `'total'`: 列表，包含了所有转换后的数据记录。
- `type_to_dataset`: 字典，以数据记录的'type'字段为键，每个键对应的值为包含该类型数据记录的列表。

## 2.16. 实现逻辑

1. 使用`open`函数以只读模式打开`data_path`路径下的`dev.json`文件，并使用`json.load`将其内容加载到`dataset`变量中。
2. 以相同方式打开`id_aliases.json`文件，逐行读取并解析为字典，更新`aliases`字典，其中键是问题 ID（Q_id），值是对应的别名列表。
3. 遍历`dataset`中的每个数据记录，构造一个新格式的数据记录`val`，包括：
   - `'qid'`: 数据记录的 ID。
   - `'test_id'`: 数据记录的索引。
   - `'question'`: 提出的问题。
   - `'answer'`: 答案，如果答案 ID 存在，则使用`aliases`中的别名，否则使用原始答案。
4. 构造`contexts`字典，其中键是上下文名称，值是这些名称对应的句子拼接成的字符串。
5. 遍历数据记录中的`'supporting_facts'`，提取对应的上下文段落，并添加到`golden_passages`列表中。
6. 将`'golden_passages'`和`'type'`添加到`val`字典中。
7. 将`val`添加到`new_dataset`列表中，并根据数据记录的`'type'`将其分类到`type_to_dataset`字典中。
8. 构造最终返回的字典`ret`，包含全部数据记录和分类后的数据记录。
9. 返回字典`ret`。

load_hotpotqa

以下是根据您提供的格式对该函数的分析：

## 2.17. 功能描述

该函数的主要功能是从指定的路径加载 HotpotQA 数据集，并对其进行处理，提取关键信息，包括问题、答案、支持的上下文段落等，然后将数据整理成特定的格式返回。

## 2.18. 参数说明

- `data_path` (str): 指向 HotpotQA 数据集所在目录的路径。函数内部会自动拼接该路径与数据集文件的名称。

## 2.19. 返回值

- 返回一个字典，包含以下两项：
  - `'total'`: 包含所有处理后的数据记录列表。
  - 类型到数据记录列表的映射，每个类型对应一个数据列表。

## 2.20. 实现逻辑

1. 将传入的`data_path`与数据集文件名拼接，形成完整的数据文件路径。
2. 打开该文件，并使用`json.load`将其内容加载为一个字典列表。
3. 遍历加载的数据，对每个记录执行以下操作：
   - 创建一个新字典`val`，包含问题 ID(`qid`)，测试 ID(`test_id`)，问题(`question`)和答案(`answer`)。
   - 从上下文数据中提取所有段落，并组合成单个字符串。
   - 遍历支持的上下文段落，将这些段落添加到临时的列表`tmp`中，确保每个段落只出现一次。
   - 将这些段落添加到`val`字典中的`golden_passages`字段。
   - 将数据类型添加到`val`字典中的`type`字段。
   - 将`val`添加到新的数据集列表`new_dataset`中，并根据类型将其添加到类型映射`type_to_dataset`中。
4. 创建返回字典`ret`，其中包含`'total'`键和对应的数据集列表。
5. 更新返回字典`ret`，将类型映射添加到其中。
6. 返回处理后的数据集字典`ret`。

load_iirc

## 2.21. 功能描述

该函数 `load_iirc` 主要功能是从指定的数据路径中读取一个名为 'dev.json' 的文件，该文件包含了一系列的问题和答案数据。函数解析这个 JSON 文件，提取每个问题及其答案和上下文信息，然后将这些信息格式化为一个列表，每个元素都是一个包含问题 ID、问题文本、答案和上下文的字典。最终，这个列表被包装在一个字典中并返回。

## 2.22. 参数说明

- `data_path`: 字符串，表示包含 'dev.json' 文件的目录路径。

## 2.23. 返回值

- 返回一个字典，包含一个键 `'total'` 对应一个列表。列表中的每个元素都是一个包含以下键的字典：
  - `'qid'`: 问题 ID，字符串类型。
  - `'question'`: 问题文本，字符串类型。
  - `'answer'`: 答案列表，列表中的元素类型为字符串或整数，取决于答案的类型。
  - `'passages'`: 上下文列表，每个元素都是上下文中的文本片段，字符串类型。

## 2.24. 实现逻辑

1. 初始化一个空列表 `dataset`，用于存储解析后的数据。
2. 使用 `with open` 语句打开并读取位于 `data_path` 路径下的 'dev.json' 文件。
3. 使用 `json.load(fin)` 将文件内容解析为 JSON 对象。
4. 使用 `tqdm` 包对 `js` 对象进行迭代，以便在处理时显示进度条。
5. 遍历 `js` 对象中的每个 `tmp` 元素，再遍历该元素中的 `'questions'` 列表。
6. 对于每个 `example` 问题，提取其 `'qid'`, `'question'`, `'answer'` 信息。
7. 根据答案类型 `'type'`，提取答案：
   - 如果 `'type'` 为 `'none'`，则跳过当前问题。
   - 如果 `'type'` 为 `'value'` 或 `'binary'`，则将答案值添加到一个列表中。
   - 如果 `'type'` 为 `'span'`，则提取所有答案跨度（`'answer_spans'`）的文本，并添加到列表中。
8. 提取 `'context'` 中的文本，并将其添加到 `context` 列表中。
9. 将所有提取的信息添加到 `dataset` 列表中。
10. 创建一个包含 `'total'` 键和对应 `dataset` 列表的字典 `ret`。
11. 返回 `ret` 字典。

load_strategyqa

## 2.25. 功能描述

该函数`load_strategyqa`的主要功能是加载并解析两个 JSON 文件，这两个文件包含 StrategyQA 数据集的训练数据。函数将读取问题、事实、证据和答案，并将它们组合成一种格式，以便于后续处理。

## 2.26. 参数说明

- `data_path`: 字符串类型，表示包含 StrategyQA 数据集文件的目录路径。

## 2.27. 返回值

- 返回一个字典`ret`，其中包含一个键`'total'`，该键对应一个列表，列表中包含解析后的数据集条目。每个条目也是一个字典，包含问题 ID、问题文本、事实、答案和相关的上下文段落。

## 2.28. 实现逻辑

1. 初始化一个空列表`dataset`，用于存储解析后的数据条目。
2. 使用`with open`语句打开`data_path`目录下的`strategyqa_train.json`文件，并使用`json.load`将其内容解析为`dataset_1`。
3. 同样地，打开`data_path`目录下的`strategyqa_train_paragraphs.json`文件，并解析为`dataset_2`。
4. 遍历`dataset_1`中的每个数据条目，使用`tqdm`库显示进度条。
5. 对于每个数据条目，创建一个`example`字典，包含问题 ID（`qid`）、问题文本（`question`）、事实（`cot`，连接为一个字符串）和答案（转换为字符串`'yes'`或`'no'`）。
6. 解析数据条目中的证据（`evidence`），提取标题（`title`），并跳过特定条件下的标题。
7. 如果标题在`dataset_2`中存在，将对应的上下文段落（`content`）添加到`ctxs`列表中。
8. 将`ctxs`列表添加到`example`字典中，键名为`'passages'`。
9. 将`example`添加到`dataset`列表中。
10. 创建一个返回字典`ret`，将`dataset`列表赋值给键`'total'`。
11. 返回`ret`字典，其中包含了解析后的数据集。

load_default_format_data

以下是对给定函数的分析：

## 2.29. 功能描述

该函数的主要功能是从指定的文件路径加载 JSON 格式的数据，并验证数据是否符合特定的格式要求。它假定 JSON 文件包含一个字典列表，每个字典至少包含一个字符串类型的`question`字段和一个字符串或字符串列表类型的`answer`字段。函数还会为每个数据项添加一个唯一的`test_id`。

## 2.30. 参数说明

- `data_path`: 一个字符串，表示 JSON 数据文件的路径。

## 2.31. 返回值

返回一个字典，其中包含文件名（不包含路径）作为键，以及加载并验证后的数据集作为值。

## 2.32. 实现逻辑

1. 从`data_path`中提取文件名。
2. 使用断言（`assert`）检查文件名是否以`.json`结尾，如果不是，则抛出异常，提醒需要 JSON 格式的数据。
3. 使用`with open`语句以只读模式打开文件，确保文件在使用后正确关闭。
4. 使用`json.load`方法从文件中加载 JSON 数据。
5. 遍历数据集中的每个数据项，并进行以下验证：
   - 使用断言检查每个数据项是否包含`question`字段，并且该字段是字符串类型。
   - 使用断言检查每个数据项是否包含`answer`字段，并且该字段是字符串类型或者字符串列表类型（列表中的每个元素都是字符串）。
6. 为每个数据项添加一个`test_id`字段，其值为当前枚举索引。
7. 返回一个包含文件名和数据集的字典。文件名是字典的键，数据集是字典的值。

get_rewrite

以下是根据您提供的格式对 `get_rewrite` 函数的分析：

## 2.33. 功能描述

该函数的主要功能是重写给定的文本段落，同时保持实体、专有名词和关键细节（如名称、地点和专业术语）不变。它旨在以不同的方式表达相同的思想和信息，同时确保修改后的段落与原文有区别，但核心意义和相关信息保持不变。

## 2.34. 参数说明

- `passage`: 原始文本段落，需要被重写。
- `model_name`: 使用的模型名称（尽管在函数签名中没有明确使用，但可能在函数内部或其他相关代码中使用）。
- `model`: 用于生成重写文本的预训练模型实例。如果未提供，则可能使用默认模型。
- `tokenizer`: 与模型对应的分词器，用于处理输入文本。如果未提供，则可能使用默认分词器。
- `generation_config`: 用于控制文本生成过程的配置。如果未提供，则可能使用默认配置。

## 2.35. 返回值

返回值是由 `model_generate` 函数生成的重写后的文本段落。返回值类型是字符串，表示原始段落的新版本。

## 2.36. 实现逻辑

- 首先，函数定义了一个 `rewrite_prompt` 字符串，其中包含了指导文本重写的指令，以及占位符 `{passage}` 来插入原始文本。
- 然后，使用 `rewrite_prompt.format(passage=passage)` 将原始文本插入到指令中，创建一个完整的提示。
- 最后，函数调用 `model_generate` 方法，传递完整的提示、模型实例、分词器和生成配置，以生成重写后的文本。

注意：`model_generate` 函数没有在提供的代码片段中定义，因此这里假设它是一个外部函数，负责处理文本生成任务。此外，`model_name` 参数在 `get_rewrite` 函数的实现中没有直接使用，可能是在其他上下文或函数调用中使用。

fix_qa

下面是根据您提供的格式对该函数`fix_qa`的分析：

## 2.37. 功能描述

该函数`fix_qa`的主要功能是对输入的`qa`列表进行处理。如果输入是一个列表且长度至少为 3，它会截取列表的前三个元素，并对每个元素进行检查以确保它们包含`question`、`answer`和`full_answer`键。此外，函数还会对`answer`的值进行类型检查和格式化。

## 2.38. 参数说明

- `qa`: 可以是任何类型的数据，但函数预期它是一个列表。列表中的每个元素都应是一个包含`question`、`answer`和`full_answer`键的字典。

## 2.39. 返回值

- 返回值是一个元组，包含两个元素：
  - 第一个元素是一个布尔值，表示处理是否成功。
  - 第二个元素是处理后的`qa`数据（如果处理成功），或者原始的`qa`数据（如果处理失败）。

## 2.40. 实现逻辑

1. 检查输入`qa`是否为列表类型。
2. 如果是列表且长度大于或等于 3，截取前三个元素。
3. 遍历截取后的列表`qa`中的每个数据元素：
   - 检查元素是否包含`question`、`answer`和`full_answer`键。如果任何一个键不存在，返回`(False, qa)`。
   - 如果`answer`是一个列表，将其转换为以逗号分隔的字符串。
   - 如果`answer`是一个整数，将其转换为字符串。
   - 如果`answer`是`None`，将其替换为字符串`'Unknown'`。
4. 如果所有元素都通过检查，返回`(True, qa)`表示处理成功。
5. 如果输入不是预期的列表或长度小于 3，返回`(False, qa)`表示处理失败。

get_qa

以下是根据您提供的格式对该函数的分析：

## 2.41. 功能描述

该函数`get_qa`的主要功能是使用指定的模型和配置来生成针对给定段落的问答对（QA）。它尝试多次生成输出，直到成功或达到尝试次数上限。

## 2.42. 参数说明

- `passage`: 一个字符串，表示需要生成问答对的文本段落。
- `model_name`: 一个字符串，表示所使用的模型名称，该名称用于确定如何处理模型的输出。
- `model`: 一个可选参数，表示预训练的模型对象，用于生成文本。
- `tokenizer`: 一个可选参数，表示与模型对应的分词器，用于处理输入和输出文本。
- `generation_config`: 一个可选参数，表示生成配置，用于指导模型生成过程。

## 2.43. 返回值

函数返回一个对象，该对象可以是以下两者之一：

- 如果成功生成有效的问答对，则返回一个包含问答信息的字典或列表。
- 如果生成过程中发生错误，或者达到尝试次数上限，则返回原始的输出文本。

## 2.44. 实现逻辑

1. 定义一个内部函数`fix_json`，用于根据不同的模型名称处理输出字符串，确保其符合 JSON 格式。
2. 设置尝试次数`try_times`为 100 次。
3. 使用`qa_prompt_template`格式化`passage`以构造提示文本。
4. 在一个循环中，使用`model_generate`函数尝试生成问答对，并调用`fix_json`处理输出。
5. 尝试将处理后的输出解析为 JSON 格式，并使用`fix_qa`函数进一步修复问答对。
6. 如果`fix_qa`返回成功标志，则返回修复后的问答对。
7. 如果解析或修复过程中发生异常，或者问答对无效，则减少尝试次数并继续循环，直到尝试次数耗尽。
8. 如果所有尝试都失败，则返回最后的输出文本。

main

## 2.45. 功能描述

该函数`main`的主要功能是加载和处理特定数据集，根据提供的参数对数据集中的每个问题进行增强，包括重写和问答对生成，并将处理后的结果保存到指定的输出目录。

## 2.46. 参数说明

- `args`: 一个包含多个参数的对象，这些参数用于指导数据加载、处理和输出的各个方面。以下是一些关键的参数：
  - `output_dir`: 输出目录的路径。
  - `dataset`: 要加载的数据集名称。
  - `model_name`: 模型名称，可能包含了路径信息。
  - `data_path`: 数据集文件路径。
  - `projector`: 一个布尔标志，指示是否使用特定的数据处理逻辑。
  - `sample`: 要处理的数据样本数量。
  - `topk`: 对于每个问题，要考虑的段落或重写数量。

## 2.47. 返回值

该函数没有明确的返回值。它通过写入文件的方式来输出处理后的数据。

## 2.48. 实现逻辑

1. **初始化输出目录**：根据参数创建输出目录，如果目录已存在则忽略。
2. **加载数据集**：
   - 检查是否存在特定于数据集的加载函数（例如`load_{args.dataset}`），如果存在，则使用该函数加载数据集。
   - 如果不存在，则使用默认的加载函数`load_default_format_data`。
3. **数据处理**：
   - 根据是否使用`projector`参数，确定数据处理的起始索引。
   - 如果数据集包含多个键（除了`'total'`），则创建一个新的字典，排除`'total'`键，并保存到文件。
4. **获取模型和分词器**：通过`get_model`函数加载模型和分词器。
5. **设置生成配置**：定义一个生成配置字典，包含生成文本时的一些参数（如最大新令牌数、返回生成字典等）。
6. **处理每个数据文件**：
   - 对于每个数据文件，创建一个进度条，遍历数据集中的每个问题。
   - 如果问题没有关联的段落，使用`bm25_retrieve`函数检索相关段落。
   - 对每个段落，生成其重写版本和问答对。
   - 如果问答对修复后的结果是有效的，将其添加到最终段落列表和增强数据中。
   - 当达到`args.topk`指定的数量时，停止添加新的段落。
7. **保存处理后的数据**：
   - 将处理后的数据集以 JSON 格式保存到指定的输出文件中。
   - 在保存之前，使用`pdb.set_trace()`调用 Python 调试器，这是一个断点，用于调试和检查数据。

请注意，这段代码中有几个问题，比如使用了`import pdb`和`pdb.set_trace()`，这是用于调试的，不应该在生产代码中出现。此外，代码中直接使用全局变量（如`ROOT_DIR`），这在函数分析中没有明确说明。
